/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console, prefer-const, object-shorthand */

require('../src/setup_node_env');

var fs = require('fs');
var path = require('path');
var util = require('util');
var exec = require('child_process').exec;

var execAsync = util.promisify(exec);

function categorizePackage(pkgPath) {
  if (pkgPath.indexOf('src/') === 0) return 'core';
  if (pkgPath.indexOf('platform/packages') !== -1) return 'platform';
  if (pkgPath.indexOf('solutions/') !== -1) return 'solution';
  if (pkgPath.indexOf('x-pack/') === 0) return 'x-pack';
  return 'platform'; // fallback
}

function analyzeMarkdown(content) {
  // Simple markdown parsing without external dependencies
  var lines = content.split('\n');

  var headingCount = 0;
  var codeBlockCount = 0;
  var linkCount = 0;
  var headings = [];

  var inCodeBlock = false;

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    // Count headings
    if (line.match(/^#+\s+/)) {
      headingCount++;
      headings.push(line.replace(/^#+\s+/, '').toLowerCase());
    }

    // Count code blocks
    if (line.match(/^```/)) {
      if (inCodeBlock) {
        codeBlockCount++;
        inCodeBlock = false;
      } else {
        inCodeBlock = true;
      }
    }

    // Count inline code
    var inlineCodeMatches = line.match(/`[^`]+`/g);
    if (inlineCodeMatches) {
      codeBlockCount += inlineCodeMatches.length;
    }

    // Count links
    var linkMatches = line.match(/\[[^\]]*\]\([^)]*\)/g);
    if (linkMatches) {
      linkCount += linkMatches.length;
    }
  }

  var wordCount = content.split(/\s+/).length;
  var contentLower = content.toLowerCase();

  // Check for key sections
  var hasInstallation = /install|setup|getting started/i.test(contentLower);
  var hasUsage = /usage|example|how to|api/i.test(contentLower);
  var hasApi = /api|interface|methods|functions/i.test(contentLower);
  var hasTesting = /test|testing|spec|jest/i.test(contentLower);
  var hasContributing = /contribut|develop|build/i.test(contentLower);

  // Check if generated
  var isGenerated = /generated by|placeholder|todo.*add/i.test(content);

  // Determine quality tier
  var qualityTier = 'none';

  if (isGenerated || wordCount < 20) {
    qualityTier = 'placeholder';
  } else if (wordCount < 100 || headingCount < 2) {
    qualityTier = 'basic';
  } else if (wordCount > 200 && headingCount > 3 && (hasUsage || hasApi)) {
    qualityTier = 'good';
  } else if (
    wordCount > 400 &&
    headingCount > 4 &&
    hasUsage &&
    hasApi &&
    (hasInstallation || hasTesting)
  ) {
    qualityTier = 'excellent';
  } else {
    qualityTier = 'basic';
  }

  return {
    wordCount: wordCount,
    headingCount: headingCount,
    codeBlockCount: codeBlockCount,
    linkCount: linkCount,
    hasInstallation: hasInstallation,
    hasUsage: hasUsage,
    hasApi: hasApi,
    hasTesting: hasTesting,
    hasContributing: hasContributing,
    isGenerated: isGenerated,
    qualityTier: qualityTier,
  };
}

function findDirectories(pattern) {
  return execAsync('find . -type d -path "./' + pattern + '" 2>/dev/null | head -1000')
    .then(function (result) {
      return result.stdout
        .trim()
        .split('\n')
        .filter(Boolean)
        .map(function (p) {
          return p.replace(/^\.\//, '');
        });
    })
    .catch(function () {
      return [];
    });
}

function runDetailedAnalysis() {
  var patterns = [
    'packages/*',
    'src/platform/*',
    'x-pack/packages/*',
    'x-pack/platform/packages/*',
    'x-pack/solutions/*/packages/*',
    'x-pack/solutions/*/plugins/*',
  ];

  var results = [];
  var promise = Promise.resolve();

  patterns.forEach(function (pattern) {
    promise = promise.then(function () {
      return findDirectories(pattern).then(function (paths) {
        paths.forEach(function (pkgPath) {
          var readmePath = path.join(pkgPath, 'README.md');
          var hasReadme = fs.existsSync(readmePath);

          var analysis = {
            wordCount: 0,
            headingCount: 0,
            codeBlockCount: 0,
            linkCount: 0,
            hasInstallation: false,
            hasUsage: false,
            hasApi: false,
            hasTesting: false,
            hasContributing: false,
            isGenerated: false,
            qualityTier: 'none',
          };

          if (hasReadme) {
            var content = fs.readFileSync(readmePath, 'utf-8');
            analysis = analyzeMarkdown(content);
          }

          results.push({
            packagePath: pkgPath,
            packageType: categorizePackage(pkgPath),
            hasReadme: hasReadme,
            analysis: analysis,
          });
        });
      });
    });
  });

  return promise.then(function () {
    // Generate comprehensive report
    var byType = {};
    results.forEach(function (r) {
      if (!byType[r.packageType]) byType[r.packageType] = [];
      byType[r.packageType].push(r);
    });

    console.log('=== Detailed Kibana Documentation Analysis ===\n');

    // Overall statistics
    var totalPackages = results.length;
    var overallTiers = {};
    results.forEach(function (item) {
      var tier = item.analysis.qualityTier;
      overallTiers[tier] = (overallTiers[tier] || 0) + 1;
    });

    console.log('Total packages analyzed: ' + totalPackages + '\n');
    console.log('=== Overall Quality Distribution ===');
    Object.keys(overallTiers).forEach(function (tier) {
      var count = overallTiers[tier];
      console.log(tier + ': ' + count + ' (' + ((count / totalPackages) * 100).toFixed(1) + '%)');
    });
    console.log();

    // Breakdown by package type
    Object.keys(byType).forEach(function (type) {
      var items = byType[type];
      console.log(type.toUpperCase() + ' (' + items.length + ' packages):');

      var tiers = {};
      items.forEach(function (item) {
        var tier = item.analysis.qualityTier;
        tiers[tier] = (tiers[tier] || 0) + 1;
      });

      Object.keys(tiers).forEach(function (tier) {
        var count = tiers[tier];
        console.log(
          '  ' + tier + ': ' + count + ' (' + ((count / items.length) * 100).toFixed(1) + '%)'
        );
      });
      console.log();
    });

    // Feature analysis
    console.log('=== Content Features Analysis ===');
    var featuresCount = {
      hasInstallation: results.filter(function (r) {
        return r.analysis.hasInstallation;
      }).length,
      hasUsage: results.filter(function (r) {
        return r.analysis.hasUsage;
      }).length,
      hasApi: results.filter(function (r) {
        return r.analysis.hasApi;
      }).length,
      hasTesting: results.filter(function (r) {
        return r.analysis.hasTesting;
      }).length,
      hasContributing: results.filter(function (r) {
        return r.analysis.hasContributing;
      }).length,
    };

    Object.keys(featuresCount).forEach(function (feature) {
      var count = featuresCount[feature];
      var featureName = feature.replace('has', '');
      console.log(
        featureName + ': ' + count + ' (' + ((count / totalPackages) * 100).toFixed(1) + '%)'
      );
    });
    console.log();

    // Examples of excellent documentation
    console.log('=== Examples of Excellent Documentation ===');
    var excellent = results
      .filter(function (r) {
        return r.analysis.qualityTier === 'excellent';
      })
      .slice(0, 5);

    if (excellent.length > 0) {
      excellent.forEach(function (r) {
        console.log(
          '- ' +
            r.packagePath +
            ' (' +
            r.analysis.wordCount +
            ' words, ' +
            r.analysis.headingCount +
            ' headings)'
        );
      });
    } else {
      console.log('No packages found with excellent documentation quality.');
    }
    console.log();

    // Packages needing improvement
    console.log('=== Packages Needing Improvement ===');
    var needsImprovement = results
      .filter(function (r) {
        return r.analysis.qualityTier === 'none' || r.analysis.qualityTier === 'placeholder';
      })
      .slice(0, 10);

    needsImprovement.forEach(function (r) {
      var reason = !r.hasReadme ? 'No README' : 'Placeholder/Generated content';
      console.log('- ' + r.packagePath + ' (' + reason + ')');
    });

    var needsImprovementTotal = results.filter(function (r) {
      return r.analysis.qualityTier === 'none' || r.analysis.qualityTier === 'placeholder';
    }).length;

    if (needsImprovementTotal > 10) {
      var remaining = needsImprovementTotal - 10;
      console.log('  ... and ' + remaining + ' more packages needing improvement');
    }

    return results;
  });
}

runDetailedAnalysis().catch(function (error) {
  console.error('Error running detailed analysis:', error);
});
