/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console */

import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

interface DetailedAnalysis {
  packagePath: string;
  packageType: 'core' | 'platform' | 'solution' | 'x-pack';
  hasReadme: boolean;
  analysis: {
    wordCount: number;
    headingCount: number;
    codeBlockCount: number;
    linkCount: number;
    hasInstallation: boolean;
    hasUsage: boolean;
    hasApi: boolean;
    hasTesting: boolean;
    hasContributing: boolean;
    isGenerated: boolean;
    qualityTier: 'none' | 'placeholder' | 'basic' | 'good' | 'excellent';
  };
}

function categorizePackage(pkgPath: string): DetailedAnalysis['packageType'] {
  if (pkgPath.startsWith('src/')) return 'core';
  if (pkgPath.includes('platform/packages')) return 'platform';
  if (pkgPath.includes('solutions/')) return 'solution';
  if (pkgPath.startsWith('x-pack/')) return 'x-pack';
  return 'platform'; // fallback
}

function analyzeMarkdown(content: string): DetailedAnalysis['analysis'] {
  // Simple markdown parsing without external dependencies
  const lines = content.split('\n');

  let headingCount = 0;
  let codeBlockCount = 0;
  let linkCount = 0;
  const headings: string[] = [];

  let inCodeBlock = false;

  for (const line of lines) {
    // Count headings
    if (line.match(/^#+\s+/)) {
      headingCount++;
      headings.push(line.replace(/^#+\s+/, '').toLowerCase());
    }

    // Count code blocks
    if (line.match(/^```/)) {
      if (inCodeBlock) {
        codeBlockCount++;
        inCodeBlock = false;
      } else {
        inCodeBlock = true;
      }
    }

    // Count inline code
    const inlineCodeMatches = line.match(/`[^`]+`/g);
    if (inlineCodeMatches) {
      codeBlockCount += inlineCodeMatches.length;
    }

    // Count links
    const linkMatches = line.match(/\[[^\]]*\]\([^)]*\)/g);
    if (linkMatches) {
      linkCount += linkMatches.length;
    }
  }

  const wordCount = content.split(/\s+/).length;
  const contentLower = content.toLowerCase();

  // Check for key sections
  const hasInstallation = /install|setup|getting started/i.test(contentLower);
  const hasUsage = /usage|example|how to|api/i.test(contentLower);
  const hasApi = /api|interface|methods|functions/i.test(contentLower);
  const hasTesting = /test|testing|spec|jest/i.test(contentLower);
  const hasContributing = /contribut|develop|build/i.test(contentLower);

  // Check if generated
  const isGenerated = /generated by|placeholder|todo.*add/i.test(content);

  // Determine quality tier
  let qualityTier: DetailedAnalysis['analysis']['qualityTier'] = 'none';

  if (isGenerated || wordCount < 20) {
    qualityTier = 'placeholder';
  } else if (wordCount < 100 || headingCount < 2) {
    qualityTier = 'basic';
  } else if (wordCount > 200 && headingCount > 3 && (hasUsage || hasApi)) {
    qualityTier = 'good';
  } else if (
    wordCount > 400 &&
    headingCount > 4 &&
    hasUsage &&
    hasApi &&
    (hasInstallation || hasTesting)
  ) {
    qualityTier = 'excellent';
  } else {
    qualityTier = 'basic';
  }

  return {
    wordCount,
    headingCount,
    codeBlockCount,
    linkCount,
    hasInstallation,
    hasUsage,
    hasApi,
    hasTesting,
    hasContributing,
    isGenerated,
    qualityTier,
  };
}

async function findDirectories(pattern: string): Promise<string[]> {
  try {
    const { stdout } = await execAsync(
      `find . -type d -path "./${pattern}" 2>/dev/null | head -1000`
    );
    return stdout
      .trim()
      .split('\n')
      .filter(Boolean)
      .map((p) => p.replace(/^\.\//, ''));
  } catch {
    return [];
  }
}

async function runDetailedAnalysis() {
  const patterns = [
    'packages/*',
    'src/platform/*',
    'x-pack/packages/*',
    'x-pack/platform/packages/*',
    'x-pack/solutions/*/packages/*',
    'x-pack/solutions/*/plugins/*',
  ];

  const results: DetailedAnalysis[] = [];

  for (const pattern of patterns) {
    const paths = await findDirectories(pattern);

    for (const pkgPath of paths) {
      const readmePath = path.join(pkgPath, 'README.md');
      const hasReadme = fs.existsSync(readmePath);

      let analysis: DetailedAnalysis['analysis'] = {
        wordCount: 0,
        headingCount: 0,
        codeBlockCount: 0,
        linkCount: 0,
        hasInstallation: false,
        hasUsage: false,
        hasApi: false,
        hasTesting: false,
        hasContributing: false,
        isGenerated: false,
        qualityTier: 'none',
      };

      if (hasReadme) {
        const content = fs.readFileSync(readmePath, 'utf-8');
        analysis = analyzeMarkdown(content);
      }

      results.push({
        packagePath: pkgPath,
        packageType: categorizePackage(pkgPath),
        hasReadme,
        analysis,
      });
    }
  }

  // Generate comprehensive report
  const byType = results.reduce((acc, r) => {
    if (!acc[r.packageType]) acc[r.packageType] = [];
    acc[r.packageType].push(r);
    return acc;
  }, {} as Record<string, DetailedAnalysis[]>);

  console.log('=== Detailed Kibana Documentation Analysis ===\n');

  // Overall statistics
  const totalPackages = results.length;
  const overallTiers = results.reduce((acc, item) => {
    acc[item.analysis.qualityTier] = (acc[item.analysis.qualityTier] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  console.log(`Total packages analyzed: ${totalPackages}\n`);
  console.log('=== Overall Quality Distribution ===');
  Object.entries(overallTiers).forEach(([tier, count]) => {
    console.log(`${tier}: ${count} (${((count / totalPackages) * 100).toFixed(1)}%)`);
  });
  console.log();

  // Breakdown by package type
  Object.entries(byType).forEach(([type, items]) => {
    console.log(`${type.toUpperCase()} (${items.length} packages):`);
    const tiers = items.reduce((acc, item) => {
      acc[item.analysis.qualityTier] = (acc[item.analysis.qualityTier] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    Object.entries(tiers).forEach(([tier, count]) => {
      console.log(`  ${tier}: ${count} (${((count / items.length) * 100).toFixed(1)}%)`);
    });
    console.log();
  });

  // Feature analysis
  console.log('=== Content Features Analysis ===');
  const featuresCount = {
    hasInstallation: results.filter((r) => r.analysis.hasInstallation).length,
    hasUsage: results.filter((r) => r.analysis.hasUsage).length,
    hasApi: results.filter((r) => r.analysis.hasApi).length,
    hasTesting: results.filter((r) => r.analysis.hasTesting).length,
    hasContributing: results.filter((r) => r.analysis.hasContributing).length,
  };

  Object.entries(featuresCount).forEach(([feature, count]) => {
    console.log(
      `${feature.replace('has', '')}: ${count} (${((count / totalPackages) * 100).toFixed(1)}%)`
    );
  });
  console.log();

  // Examples of excellent documentation
  console.log('=== Examples of Excellent Documentation ===');
  const excellent = results.filter((r) => r.analysis.qualityTier === 'excellent').slice(0, 5);
  if (excellent.length > 0) {
    excellent.forEach((r) => {
      console.log(
        `- ${r.packagePath} (${r.analysis.wordCount} words, ${r.analysis.headingCount} headings)`
      );
    });
  } else {
    console.log('No packages found with excellent documentation quality.');
  }
  console.log();

  // Packages needing improvement
  console.log('=== Packages Needing Improvement ===');
  const needsImprovement = results
    .filter((r) => r.analysis.qualityTier === 'none' || r.analysis.qualityTier === 'placeholder')
    .slice(0, 10);

  needsImprovement.forEach((r) => {
    const reason = !r.hasReadme ? 'No README' : 'Placeholder/Generated content';
    console.log(`- ${r.packagePath} (${reason})`);
  });

  if (results.filter((r) => ['none', 'placeholder'].includes(r.analysis.qualityTier)).length > 10) {
    const remaining =
      results.filter((r) => ['none', 'placeholder'].includes(r.analysis.qualityTier)).length - 10;
    console.log(`  ... and ${remaining} more packages needing improvement`);
  }

  return results;
}

runDetailedAnalysis().catch((error) => {
  console.error('Error running detailed analysis:', error);
});
