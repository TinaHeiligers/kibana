/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console, prefer-const, object-shorthand */

require('../src/setup_node_env');

var fs = require('fs');
var path = require('path');
var util = require('util');
var exec = require('child_process').exec;

// Help functionality
function showHelp() {
  console.log(`
Kibana Documentation Analysis - Basic Approach

DESCRIPTION:
  Analyzes README files across all Kibana packages and plugins.
  Provides balanced detail and performance with quality scoring.

USAGE:
  node scripts/analyze_documentation.js [options]

OPTIONS:
  -h, --help     Show this help message
  -v, --verbose  Show additional detailed output

FEATURES:
  • Analyzes README files across all package directories
  • Generates quality scores based on content indicators
  • Identifies generated/placeholder content
  • Provides detailed statistics and examples
  • Categorizes documentation by quality levels

QUALITY SCORING:
  • Low Quality (≤3): Minimal content, few sections
  • Medium Quality (4-6): Adequate documentation with some structure
  • High Quality (>6): Comprehensive with multiple sections and examples

EXAMPLES:
  # Basic analysis
  node scripts/analyze_documentation.js
  
  # Verbose output with more details
  node scripts/analyze_documentation.js --verbose

SEE ALSO:
  • scripts/advanced_doc_analysis.js - More comprehensive analysis
  • scripts/doc_analysis.sh - Faster shell-based analysis
  • scripts/run_doc_analysis.sh - Interactive runner for all approaches
`);
}

// Parse command line arguments
var args = process.argv.slice(2);
var verbose = false;

for (var i = 0; i < args.length; i++) {
  var arg = args[i];
  if (arg === '-h' || arg === '--help') {
    showHelp();
    process.exit(0);
  } else if (arg === '-v' || arg === '--verbose') {
    verbose = true;
  } else {
    console.error('Unknown option: ' + arg);
    console.error('Use --help for usage information');
    process.exit(1);
  }
}

var execAsync = util.promisify(exec);

// Define patterns that indicate generated/placeholder content
var GENERATED_PATTERNS = [
  /This is a placeholder README/i,
  /TODO: Add documentation/i,
  /Empty package generated by @kbn\/plugin-generator/i,
  /This plugin was generated/i,
  /Add your plugin description here/i,
];

var QUALITY_INDICATORS = {
  installation: /installation|install|setup/i,
  usage: /usage|example|how to/i,
  api: /api|interface|methods/i,
  testing: /test|testing|spec/i,
  contributing: /contribut|develop/i,
  architecture: /architecture|design|structure/i,
};

function analyzeReadme(content) {
  var wordCount = content.split(/\s+/).length;
  var isGenerated = GENERATED_PATTERNS.some(function (pattern) {
    return pattern.test(content);
  });
  var isPlaceholder = wordCount < 50 || isGenerated;

  // Extract sections (lines starting with #)
  var sections = content.match(/^#+\s+(.+)$/gm) || [];

  // Calculate quality score
  var qualityScore = 0;
  if (wordCount > 100) qualityScore += 2;
  if (wordCount > 300) qualityScore += 3;

  Object.values(QUALITY_INDICATORS).forEach(function (pattern) {
    if (pattern.test(content)) qualityScore += 1;
  });

  if (sections.length > 3) qualityScore += 2;

  return {
    isGenerated: isGenerated,
    isPlaceholder: isPlaceholder,
    qualityScore: Math.min(qualityScore, 10),
    wordCount: wordCount,
    sections: sections.map(function (s) {
      return s.replace(/^#+\s+/, '');
    }),
  };
}

function findDirectories(pattern) {
  return execAsync('find . -type d -path "./' + pattern + '" 2>/dev/null | head -1000')
    .then(function (result) {
      return result.stdout
        .trim()
        .split('\n')
        .filter(Boolean)
        .map(function (p) {
          return p.replace(/^\.\//, '');
        });
    })
    .catch(function () {
      return [];
    });
}

function analyzeDocumentation() {
  var packageDirs = [
    'packages/*',
    'src/platform/*',
    'x-pack/packages/*',
    'x-pack/platform/packages/*',
    'x-pack/solutions/*/packages/*',
    'x-pack/solutions/*/plugins/*',
  ];

  var results = [];
  var promise = Promise.resolve();

  packageDirs.forEach(function (pattern) {
    promise = promise.then(function () {
      return findDirectories(pattern).then(function (paths) {
        paths.forEach(function (pkgPath) {
          var readmePath = path.join(pkgPath, 'README.md');
          var hasReadme = fs.existsSync(readmePath);

          var analysis = {
            hasReadme: false,
            isGenerated: false,
            isPlaceholder: true,
            qualityScore: 0,
            wordCount: 0,
            sections: [],
          };

          if (hasReadme) {
            var content = fs.readFileSync(readmePath, 'utf-8');
            var readmeAnalysis = analyzeReadme(content);
            analysis = Object.assign(analysis, { hasReadme: true }, readmeAnalysis);
          }

          results.push(Object.assign({ packagePath: pkgPath }, analysis));
        });
      });
    });
  });

  return promise.then(function () {
    return results;
  });
}

// Generate comprehensive report
analyzeDocumentation()
  .then(function (results) {
    var stats = {
      total: results.length,
      noReadme: results.filter(function (r) {
        return !r.hasReadme;
      }).length,
      hasReadme: results.filter(function (r) {
        return r.hasReadme;
      }).length,
      generated: results.filter(function (r) {
        return r.isGenerated;
      }).length,
      placeholder: results.filter(function (r) {
        return r.isPlaceholder;
      }).length,
      lowQuality: results.filter(function (r) {
        return r.qualityScore <= 3;
      }).length,
      mediumQuality: results.filter(function (r) {
        return r.qualityScore > 3 && r.qualityScore <= 6;
      }).length,
      highQuality: results.filter(function (r) {
        return r.qualityScore > 6;
      }).length,
    };

    console.log('Kibana Documentation Analysis:');
    console.log('Total packages/plugins: ' + stats.total);
    console.log(
      'No README: ' +
        stats.noReadme +
        ' (' +
        ((stats.noReadme / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Generated/Placeholder: ' +
        stats.placeholder +
        ' (' +
        ((stats.placeholder / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Low Quality (≤3): ' +
        stats.lowQuality +
        ' (' +
        ((stats.lowQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Medium Quality (4-6): ' +
        stats.mediumQuality +
        ' (' +
        ((stats.mediumQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'High Quality (>6): ' +
        stats.highQuality +
        ' (' +
        ((stats.highQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );

    // Additional detailed output (always show basic breakdown)
    console.log('\n=== Detailed Breakdown ===');
    console.log('Packages without README:');
    results
      .filter(function (r) {
        return !r.hasReadme;
      })
      .slice(0, verbose ? 20 : 10)
      .forEach(function (r) {
        console.log('  - ' + r.packagePath);
      });

    var noReadmeCount = results.filter(function (r) {
      return !r.hasReadme;
    }).length;
    if (noReadmeCount > (verbose ? 20 : 10)) {
      console.log('  ... and ' + (noReadmeCount - (verbose ? 20 : 10)) + ' more');
    }

    console.log('\nHigh quality documentation examples:');
    results
      .filter(function (r) {
        return r.qualityScore > 6;
      })
      .slice(0, verbose ? 10 : 5)
      .forEach(function (r) {
        console.log(
          '  - ' + r.packagePath + ' (score: ' + r.qualityScore + ', ' + r.wordCount + ' words)'
        );
      });

    // Show additional verbose information
    if (verbose) {
      console.log('\n=== Verbose Output ===');
      console.log('Generated/Placeholder content examples:');
      results
        .filter(function (r) {
          return r.isGenerated || r.isPlaceholder;
        })
        .slice(0, 10)
        .forEach(function (r) {
          console.log(
            '  - ' +
              r.packagePath +
              ' (placeholder: ' +
              r.isPlaceholder +
              ', generated: ' +
              r.isGenerated +
              ')'
          );
        });

      console.log('\nMedium quality documentation examples:');
      results
        .filter(function (r) {
          return r.qualityScore > 3 && r.qualityScore <= 6;
        })
        .slice(0, 10)
        .forEach(function (r) {
          console.log(
            '  - ' +
              r.packagePath +
              ' (score: ' +
              r.qualityScore +
              ', ' +
              r.wordCount +
              ' words, ' +
              r.sections.length +
              ' sections)'
          );
        });
    }
  })
  .catch(function (error) {
    console.error('Error running documentation analysis:', error);
  });
