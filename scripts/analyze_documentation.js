/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console, prefer-const, object-shorthand */

require('../src/setup_node_env');

var fs = require('fs');
var path = require('path');
var util = require('util');
var exec = require('child_process').exec;

var execAsync = util.promisify(exec);

// Define patterns that indicate generated/placeholder content
var GENERATED_PATTERNS = [
  /This is a placeholder README/i,
  /TODO: Add documentation/i,
  /Empty package generated by @kbn\/plugin-generator/i,
  /This plugin was generated/i,
  /Add your plugin description here/i,
];

var QUALITY_INDICATORS = {
  installation: /installation|install|setup/i,
  usage: /usage|example|how to/i,
  api: /api|interface|methods/i,
  testing: /test|testing|spec/i,
  contributing: /contribut|develop/i,
  architecture: /architecture|design|structure/i,
};

function analyzeReadme(content) {
  var wordCount = content.split(/\s+/).length;
  var isGenerated = GENERATED_PATTERNS.some(function (pattern) {
    return pattern.test(content);
  });
  var isPlaceholder = wordCount < 50 || isGenerated;

  // Extract sections (lines starting with #)
  var sections = content.match(/^#+\s+(.+)$/gm) || [];

  // Calculate quality score
  var qualityScore = 0;
  if (wordCount > 100) qualityScore += 2;
  if (wordCount > 300) qualityScore += 3;

  Object.values(QUALITY_INDICATORS).forEach(function (pattern) {
    if (pattern.test(content)) qualityScore += 1;
  });

  if (sections.length > 3) qualityScore += 2;

  return {
    isGenerated: isGenerated,
    isPlaceholder: isPlaceholder,
    qualityScore: Math.min(qualityScore, 10),
    wordCount: wordCount,
    sections: sections.map(function (s) {
      return s.replace(/^#+\s+/, '');
    }),
  };
}

function findDirectories(pattern) {
  return execAsync('find . -type d -path "./' + pattern + '" 2>/dev/null | head -1000')
    .then(function (result) {
      return result.stdout
        .trim()
        .split('\n')
        .filter(Boolean)
        .map(function (p) {
          return p.replace(/^\.\//, '');
        });
    })
    .catch(function () {
      return [];
    });
}

function analyzeDocumentation() {
  var packageDirs = [
    'packages/*',
    'src/platform/*',
    'x-pack/packages/*',
    'x-pack/platform/packages/*',
    'x-pack/solutions/*/packages/*',
    'x-pack/solutions/*/plugins/*',
  ];

  var results = [];
  var promise = Promise.resolve();

  packageDirs.forEach(function (pattern) {
    promise = promise.then(function () {
      return findDirectories(pattern).then(function (paths) {
        paths.forEach(function (pkgPath) {
          var readmePath = path.join(pkgPath, 'README.md');
          var hasReadme = fs.existsSync(readmePath);

          var analysis = {
            hasReadme: false,
            isGenerated: false,
            isPlaceholder: true,
            qualityScore: 0,
            wordCount: 0,
            sections: [],
          };

          if (hasReadme) {
            var content = fs.readFileSync(readmePath, 'utf-8');
            var readmeAnalysis = analyzeReadme(content);
            analysis = Object.assign(analysis, { hasReadme: true }, readmeAnalysis);
          }

          results.push(Object.assign({ packagePath: pkgPath }, analysis));
        });
      });
    });
  });

  return promise.then(function () {
    return results;
  });
}

// Generate comprehensive report
analyzeDocumentation()
  .then(function (results) {
    var stats = {
      total: results.length,
      noReadme: results.filter(function (r) {
        return !r.hasReadme;
      }).length,
      hasReadme: results.filter(function (r) {
        return r.hasReadme;
      }).length,
      generated: results.filter(function (r) {
        return r.isGenerated;
      }).length,
      placeholder: results.filter(function (r) {
        return r.isPlaceholder;
      }).length,
      lowQuality: results.filter(function (r) {
        return r.qualityScore <= 3;
      }).length,
      mediumQuality: results.filter(function (r) {
        return r.qualityScore > 3 && r.qualityScore <= 6;
      }).length,
      highQuality: results.filter(function (r) {
        return r.qualityScore > 6;
      }).length,
    };

    console.log('Kibana Documentation Analysis:');
    console.log('Total packages/plugins: ' + stats.total);
    console.log(
      'No README: ' +
        stats.noReadme +
        ' (' +
        ((stats.noReadme / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Generated/Placeholder: ' +
        stats.placeholder +
        ' (' +
        ((stats.placeholder / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Low Quality (â‰¤3): ' +
        stats.lowQuality +
        ' (' +
        ((stats.lowQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'Medium Quality (4-6): ' +
        stats.mediumQuality +
        ' (' +
        ((stats.mediumQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );
    console.log(
      'High Quality (>6): ' +
        stats.highQuality +
        ' (' +
        ((stats.highQuality / stats.total) * 100).toFixed(1) +
        '%)'
    );

    // Additional detailed output
    console.log('\n=== Detailed Breakdown ===');
    console.log('Packages without README:');
    results
      .filter(function (r) {
        return !r.hasReadme;
      })
      .slice(0, 10)
      .forEach(function (r) {
        console.log('  - ' + r.packagePath);
      });

    var noReadmeCount = results.filter(function (r) {
      return !r.hasReadme;
    }).length;
    if (noReadmeCount > 10) {
      console.log('  ... and ' + (noReadmeCount - 10) + ' more');
    }

    console.log('\nHigh quality documentation examples:');
    results
      .filter(function (r) {
        return r.qualityScore > 6;
      })
      .slice(0, 5)
      .forEach(function (r) {
        console.log(
          '  - ' + r.packagePath + ' (score: ' + r.qualityScore + ', ' + r.wordCount + ' words)'
        );
      });
  })
  .catch(function (error) {
    console.error('Error running documentation analysis:', error);
  });
