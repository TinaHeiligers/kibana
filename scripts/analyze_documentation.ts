/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console */

import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

interface DocumentationStats {
  packagePath: string;
  hasReadme: boolean;
  isGenerated: boolean;
  isPlaceholder: boolean;
  qualityScore: number;
  wordCount: number;
  sections: string[];
}

// Define patterns that indicate generated/placeholder content
const GENERATED_PATTERNS = [
  /This is a placeholder README/i,
  /TODO: Add documentation/i,
  /Empty package generated by @kbn\/plugin-generator/i,
  /This plugin was generated/i,
  /Add your plugin description here/i,
];

const QUALITY_INDICATORS = {
  installation: /installation|install|setup/i,
  usage: /usage|example|how to/i,
  api: /api|interface|methods/i,
  testing: /test|testing|spec/i,
  contributing: /contribut|develop/i,
  architecture: /architecture|design|structure/i,
};

function analyzeReadme(content: string): Partial<DocumentationStats> {
  const wordCount = content.split(/\s+/).length;
  const isGenerated = GENERATED_PATTERNS.some((pattern) => pattern.test(content));
  const isPlaceholder = wordCount < 50 || isGenerated;

  // Extract sections (lines starting with #)
  const sections = content.match(/^#+\s+(.+)$/gm) || [];

  // Calculate quality score
  let qualityScore = 0;
  if (wordCount > 100) qualityScore += 2;
  if (wordCount > 300) qualityScore += 3;

  Object.values(QUALITY_INDICATORS).forEach((pattern) => {
    if (pattern.test(content)) qualityScore += 1;
  });

  if (sections.length > 3) qualityScore += 2;

  return {
    isGenerated,
    isPlaceholder,
    qualityScore: Math.min(qualityScore, 10),
    wordCount,
    sections: sections.map((s) => s.replace(/^#+\s+/, '')),
  };
}

async function findDirectories(pattern: string): Promise<string[]> {
  try {
    const { stdout } = await execAsync(
      `find . -type d -path "./${pattern}" 2>/dev/null | head -1000`
    );
    return stdout
      .trim()
      .split('\n')
      .filter(Boolean)
      .map((p) => p.replace(/^\.\//, ''));
  } catch {
    return [];
  }
}

async function analyzeDocumentation() {
  const packageDirs = [
    'packages/*',
    'src/platform/*',
    'x-pack/packages/*',
    'x-pack/platform/packages/*',
    'x-pack/solutions/*/packages/*',
    'x-pack/solutions/*/plugins/*',
  ];

  const results: DocumentationStats[] = [];

  for (const pattern of packageDirs) {
    const paths = await findDirectories(pattern);

    for (const pkgPath of paths) {
      const readmePath = path.join(pkgPath, 'README.md');
      const hasReadme = fs.existsSync(readmePath);

      let analysis: Partial<DocumentationStats> = {
        hasReadme: false,
        isGenerated: false,
        isPlaceholder: true,
        qualityScore: 0,
        wordCount: 0,
        sections: [],
      };

      if (hasReadme) {
        const content = fs.readFileSync(readmePath, 'utf-8');
        analysis = { ...analysis, hasReadme: true, ...analyzeReadme(content) };
      }

      results.push({
        packagePath: pkgPath,
        ...analysis,
      } as DocumentationStats);
    }
  }

  return results;
}

// Generate comprehensive report
analyzeDocumentation()
  .then((results) => {
    const stats = {
      total: results.length,
      noReadme: results.filter((r) => !r.hasReadme).length,
      hasReadme: results.filter((r) => r.hasReadme).length,
      generated: results.filter((r) => r.isGenerated).length,
      placeholder: results.filter((r) => r.isPlaceholder).length,
      lowQuality: results.filter((r) => r.qualityScore <= 3).length,
      mediumQuality: results.filter((r) => r.qualityScore > 3 && r.qualityScore <= 6).length,
      highQuality: results.filter((r) => r.qualityScore > 6).length,
    };

    console.log('Kibana Documentation Analysis:');
    console.log(`Total packages/plugins: ${stats.total}`);
    console.log(
      `No README: ${stats.noReadme} (${((stats.noReadme / stats.total) * 100).toFixed(1)}%)`
    );
    console.log(
      `Generated/Placeholder: ${stats.placeholder} (${(
        (stats.placeholder / stats.total) *
        100
      ).toFixed(1)}%)`
    );
    console.log(
      `Low Quality (â‰¤3): ${stats.lowQuality} (${((stats.lowQuality / stats.total) * 100).toFixed(
        1
      )}%)`
    );
    console.log(
      `Medium Quality (4-6): ${stats.mediumQuality} (${(
        (stats.mediumQuality / stats.total) *
        100
      ).toFixed(1)}%)`
    );
    console.log(
      `High Quality (>6): ${stats.highQuality} (${((stats.highQuality / stats.total) * 100).toFixed(
        1
      )}%)`
    );

    // Additional detailed output
    console.log('\n=== Detailed Breakdown ===');
    console.log('Packages without README:');
    results
      .filter((r) => !r.hasReadme)
      .slice(0, 10)
      .forEach((r) => {
        console.log(`  - ${r.packagePath}`);
      });

    if (results.filter((r) => !r.hasReadme).length > 10) {
      console.log(`  ... and ${results.filter((r) => !r.hasReadme).length - 10} more`);
    }

    console.log('\nHigh quality documentation examples:');
    results
      .filter((r) => r.qualityScore > 6)
      .slice(0, 5)
      .forEach((r) => {
        console.log(`  - ${r.packagePath} (score: ${r.qualityScore}, ${r.wordCount} words)`);
      });
  })
  .catch((error) => {
    console.error('Error running documentation analysis:', error);
  });
