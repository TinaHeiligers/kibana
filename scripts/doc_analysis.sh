#!/bin/bash
# filepath: scripts/doc_analysis.sh

# Help functionality
show_help() {
  cat << 'EOF'

Kibana Documentation Analysis - Shell Approach

DESCRIPTION:
  Fast shell script using find and grep for quick documentation metrics.
  Fastest execution for quick overview of documentation status.

USAGE:
  ./scripts/doc_analysis.sh [options]

OPTIONS:
  -h, --help     Show this help message
  -v, --verbose  Show additional detailed output and examples

FEATURES:
  • Fastest execution for quick metrics
  • Uses native shell commands (find, grep, wc)
  • Comprehensive package discovery via package.json detection
  • Excludes test fixtures and build artifacts for accurate counts
  • Detects "Empty package generated by @kbn/generate" patterns
  • Provides accurate statistics and breakdowns
  • Shows examples of packages without documentation

QUALITY CATEGORIES:
  • No Documentation: Packages without README.md files
  • Generated/Placeholder: Contains @kbn/generate or placeholder content
  • Minimal Documentation: READMEs with <100 words
  • Comprehensive Documentation: READMEs with >300 words + multiple sections

EXAMPLES:
  # Basic analysis
  ./scripts/doc_analysis.sh

  # Verbose output with more examples
  ./scripts/doc_analysis.sh --verbose

PERFORMANCE:
  Fastest approach (~5-10 seconds) for quick documentation overview.

SEE ALSO:
  • scripts/analyze_documentation.js - More detailed analysis with quality scoring
  • scripts/advanced_doc_analysis.js - Most comprehensive analysis
  • scripts/run_doc_analysis.sh - Interactive runner for all approaches

EOF
}

# Parse command line arguments
verbose=false
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      show_help
      exit 0
      ;;
    -v|--verbose)
      verbose=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

echo "=== Kibana Documentation Analysis ==="

# Function to find all package directories (those containing package.json)
find_all_packages() {
  find . -name "package.json" \
    -not -path "./node_modules/*" \
    -not -path "./.es/*" \
    -not -path "./target/*" \
    -not -path "./bazel-*" \
    -not -path "./.moon/*" \
    -not -path "*/node_modules/*" \
    -not -path "*/__fixtures__/*" \
    -not -path "*/integration_tests/*" \
    -not -path "*/test_fixtures/*" \
    -exec dirname {} \; | sort -u
}

# Get all package directories
all_packages=($(find_all_packages))
total_dirs=${#all_packages[@]}

# Also count packages that should have READMEs (exclude root and some special cases)
packages_should_have_readme=()
for pkg in "${all_packages[@]}"; do
  # Skip root package and some special directories
  if [[ "$pkg" != "." && "$pkg" != "./config" && "$pkg" != "./scripts" && ! "$pkg" =~ .*/(integration_tests|__fixtures__|test_fixtures|test_data|mocks)/.* ]]; then
    packages_should_have_readme+=("$pkg")
  fi
done
total_dirs=${#packages_should_have_readme[@]}

echo "Total packages/plugins found: $total_dirs"

# Find directories without README.md
echo -n "Packages without README.md: "
no_readme=0
for dir in "${packages_should_have_readme[@]}"; do
  if [[ ! -f "$dir/README.md" ]]; then
    ((no_readme++))
  fi
done

if [ $total_dirs -gt 0 ]; then
  percentage=$(echo "scale=1; $no_readme * 100 / $total_dirs" | bc 2>/dev/null || echo "0.0")
  echo "$no_readme ($percentage%)"
else
  echo "$no_readme (0.0%)"
fi

# Find generated/placeholder READMEs
echo -n "Generated/Placeholder READMEs: "
generated=0
for dir in "${packages_should_have_readme[@]}"; do
  if [[ -f "$dir/README.md" ]]; then
    if grep -q -E "(Empty package generated by @kbn/generate|This is a placeholder|TODO: Add documentation|Generated by.*generator|Add your plugin description)" "$dir/README.md" 2>/dev/null; then
      ((generated++))
    fi
  fi
done
echo "$generated"

# Find short READMEs (likely minimal) - only count those that exist
echo -n "Short READMEs (<100 words): "
short_readmes=0
for dir in "${packages_should_have_readme[@]}"; do
  if [[ -f "$dir/README.md" ]]; then
    word_count=$(wc -w < "$dir/README.md" 2>/dev/null || echo 0)
    if [[ $word_count -lt 100 ]]; then
      ((short_readmes++))
    fi
  fi
done
echo "$short_readmes"

# Find comprehensive READMEs (with multiple sections) - only count those that exist
echo -n "Comprehensive READMEs (>300 words + sections): "
comprehensive=0
for dir in "${packages_should_have_readme[@]}"; do
  if [[ -f "$dir/README.md" ]]; then
    word_count=$(wc -w < "$dir/README.md" 2>/dev/null || echo 0)
    section_count=$(grep -c "^#" "$dir/README.md" 2>/dev/null || echo 0)
    if [[ $word_count -gt 300 && $section_count -gt 3 ]]; then
      ((comprehensive++))
    fi
  fi
done
echo "$comprehensive"

echo ""
echo "=== Quality Breakdown ==="
echo "No Documentation: $no_readme"
echo "Generated/Placeholder: $generated"
echo "Minimal Documentation: $short_readmes"
echo "Comprehensive Documentation: $comprehensive"

# Calculate and display percentages for quality breakdown
if [ $total_dirs -gt 0 ]; then
  echo ""
  echo "=== Percentage Breakdown ==="
  no_doc_pct=$(echo "scale=1; $no_readme * 100 / $total_dirs" | bc 2>/dev/null || echo "0.0")
  gen_pct=$(echo "scale=1; $generated * 100 / $total_dirs" | bc 2>/dev/null || echo "0.0")
  min_pct=$(echo "scale=1; $short_readmes * 100 / $total_dirs" | bc 2>/dev/null || echo "0.0")
  comp_pct=$(echo "scale=1; $comprehensive * 100 / $total_dirs" | bc 2>/dev/null || echo "0.0")

  echo "No Documentation: $no_doc_pct%"
  echo "Generated/Placeholder: $gen_pct%"
  echo "Minimal Documentation: $min_pct%"
  echo "Comprehensive Documentation: $comp_pct%"
fi

# Show examples of packages without READMEs
echo ""
echo "=== Examples of packages without README.md ==="
count=0
max_examples=$([ "$verbose" = true ] && echo 20 || echo 10)
for dir in "${packages_should_have_readme[@]}"; do
  if [[ ! -f "$dir/README.md" && $count -lt $max_examples ]]; then
    echo "  - $dir"
    ((count++))
  fi
  if [[ $count -ge $max_examples ]]; then
    break
  fi
done

if [[ $no_readme -gt $max_examples ]]; then
  echo "  ... and $((no_readme - max_examples)) more packages without README.md"
fi

# Show additional verbose information
if [ "$verbose" = true ]; then
  echo ""
  echo "=== Verbose Output ==="

  echo "Examples of generated/placeholder READMEs:"
  count=0
  for dir in "${packages_should_have_readme[@]}"; do
    if [[ -f "$dir/README.md" && $count -lt 10 ]]; then
      if grep -q -E "(Empty package generated by @kbn/generate|This is a placeholder|TODO: Add documentation|Generated by.*generator|Add your plugin description)" "$dir/README.md" 2>/dev/null; then
        echo "  - $dir"
        ((count++))
      fi
    fi
    if [[ $count -ge 10 ]]; then
      break
    fi
  done

  echo ""
  echo "Examples of comprehensive READMEs:"
  count=0
  for dir in "${packages_should_have_readme[@]}"; do
    if [[ -f "$dir/README.md" && $count -lt 10 ]]; then
      word_count=$(wc -w < "$dir/README.md" 2>/dev/null || echo 0)
      section_count=$(grep -c "^#" "$dir/README.md" 2>/dev/null || echo 0)
      if [[ $word_count -gt 300 && $section_count -gt 3 ]]; then
        echo "  - $dir ($word_count words, $section_count sections)"
        ((count++))
      fi
    fi
    if [[ $count -ge 10 ]]; then
      break
    fi
  done

  echo ""
  echo "Package distribution by directory:"
  echo "  - packages/: $(find ./packages -name "package.json" 2>/dev/null | wc -l | tr -d ' ')"
  echo "  - src/: $(find ./src -name "package.json" 2>/dev/null | wc -l | tr -d ' ')"
  echo "  - x-pack/packages/: $(find ./x-pack/packages -name "package.json" 2>/dev/null | wc -l | tr -d ' ')"
  echo "  - x-pack/platform/: $(find ./x-pack/platform -name "package.json" 2>/dev/null | wc -l | tr -d ' ')"
  echo "  - x-pack/solutions/: $(find ./x-pack/solutions -name "package.json" 2>/dev/null | wc -l | tr -d ' ')"
fi
