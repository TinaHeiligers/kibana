/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import moment from 'moment';

import { configServiceMock } from '../config/mocks';
import { mockOpsCollector } from './metrics_service.test.mocks';
import { MetricsService } from './metrics_service';
import { mockCoreContext } from '../core_context.mock';
import { httpServiceMock } from '../http/http_service.mock';
import { loggingSystemMock } from '../logging/logging_system.mock';
import { take } from 'rxjs/operators';

const testInterval = 100;

const dummyMetrics = { metricA: 'value', metricB: 'otherValue' };

const logger = loggingSystemMock.create();

describe('MetricsService', () => {
  const httpMock = httpServiceMock.createInternalSetupContract();
  let metricsService: MetricsService;

  beforeEach(() => {
    jest.useFakeTimers();

    const configService = configServiceMock.create({
      atPath: { interval: moment.duration(testInterval) },
    });
    const coreContext = mockCoreContext.create({ logger, configService });
    metricsService = new MetricsService(coreContext);
  });

  afterEach(() => {
    jest.clearAllMocks();
    jest.clearAllTimers();
  });

  describe('#start', () => {
    it('invokes setInterval with the configured interval', async () => {
      await metricsService.setup({ http: httpMock });
      await metricsService.start();

      expect(setInterval).toHaveBeenCalledTimes(1);
      expect(setInterval).toHaveBeenCalledWith(expect.any(Function), testInterval);
    });

    it('collects the metrics at every interval', async () => {
      mockOpsCollector.collect.mockResolvedValue(dummyMetrics);

      await metricsService.setup({ http: httpMock });
      await metricsService.start();

      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(1);

      jest.advanceTimersByTime(testInterval);
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(2);

      jest.advanceTimersByTime(testInterval);
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(3);
    });

    it('resets the collector after each collection', async () => {
      mockOpsCollector.collect.mockResolvedValue(dummyMetrics);

      await metricsService.setup({ http: httpMock });
      const { getOpsMetrics$ } = await metricsService.start();

      // `advanceTimersByTime` only ensure the interval handler is executed
      // however the `reset` call is executed after the async call to `collect`
      // meaning that we are going to miss the call if we don't wait for the
      // actual observable emission that is performed after. The extra
      // `nextTick` is to ensure we've done a complete roundtrip of the event
      // loop.
      const nextEmission = async () => {
        jest.advanceTimersByTime(testInterval);
        await getOpsMetrics$().pipe(take(1)).toPromise();
        await new Promise((resolve) => process.nextTick(resolve));
      };

      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(1);
      expect(mockOpsCollector.reset).toHaveBeenCalledTimes(1);

      await nextEmission();
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(2);
      expect(mockOpsCollector.reset).toHaveBeenCalledTimes(2);

      await nextEmission();
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(3);
      expect(mockOpsCollector.reset).toHaveBeenCalledTimes(3);
    });

    it('throws when called before setup', async () => {
      await expect(metricsService.start()).rejects.toThrowErrorMatchingInlineSnapshot(
        `"#setup() needs to be run first"`
      );
    });

    it('emits the last value on each getOpsMetrics$ call', async () => {
      const firstMetrics = { metric: 'first' };
      const secondMetrics = { metric: 'second' };
      mockOpsCollector.collect
        .mockResolvedValueOnce(firstMetrics)
        .mockResolvedValueOnce(secondMetrics);

      await metricsService.setup({ http: httpMock });
      const { getOpsMetrics$ } = await metricsService.start();

      const nextEmission = async () => {
        jest.advanceTimersByTime(testInterval);
        const emission = await getOpsMetrics$().pipe(take(1)).toPromise();
        await new Promise((resolve) => process.nextTick(resolve));
        return emission;
      };

      expect(await nextEmission()).toEqual({ metric: 'first' });
      expect(await nextEmission()).toEqual({ metric: 'second' });
    });

    it('logs the metrics at every interval', async () => {
      const firstMetrics = {
        process: {
          memory: { heap: { used_in_bytes: 100 } },
          uptime_in_millis: 1500,
          event_loop_delay: 50,
        },
        os: {
          load: [10, 20, 30],
        },
      };
      const secondMetrics = {
        process: {
          memory: { heap: { used_in_bytes: 200 } },
          uptime_in_millis: 3000,
          event_loop_delay: 100,
        },
        os: {
          load: [20, 30, 40],
        },
      };

      const opsLogger = logger.get('metrics', 'ops');

      mockOpsCollector.collect
        .mockResolvedValueOnce(firstMetrics)
        .mockResolvedValueOnce(secondMetrics);
      await metricsService.setup({ http: httpMock });
      const { getOpsMetrics$ } = await metricsService.start();

      const nextEmission = async () => {
        jest.advanceTimersByTime(testInterval);
        const emission = await getOpsMetrics$().pipe(take(1)).toPromise();
        await new Promise((resolve) => process.nextTick(resolve));
        return emission;
      };
      expect(loggingSystemMock.collect(opsLogger).debug[1]).toMatchInlineSnapshot(`
        Array [
          "{\\"memory\\":\\"100.0B\\",\\"uptime\\":\\"0:00:02\\",\\"load\\":[\\"10.00\\",\\"20.00\\",\\"30.00\\"],\\"delay\\":\\"50.000\\"}",
          Object {
            "category": Array [
              "process",
              "host",
            ],
            "ecs": Object {
              "version": "1.7.0",
            },
            "host": Object {
              "os": Object {
                "load": Array [
                  10,
                  20,
                  30,
                ],
              },
            },
            "kind": "metric",
            "process": Object {
              "eventLoopDelay": 50,
              "memory": Object {
                "heap": Object {
                  "usedInBytes": 100,
                },
              },
              "uptime": 1.5,
            },
          },
        ]
      `);
      await nextEmission();
      expect(loggingSystemMock.collect(opsLogger).debug[3]).toMatchInlineSnapshot(`
        Array [
          "{\\"memory\\":\\"200.0B\\",\\"uptime\\":\\"0:00:03\\",\\"load\\":[\\"20.00\\",\\"30.00\\",\\"40.00\\"],\\"delay\\":\\"100.000\\"}",
          Object {
            "category": Array [
              "process",
              "host",
            ],
            "ecs": Object {
              "version": "1.7.0",
            },
            "host": Object {
              "os": Object {
                "load": Array [
                  20,
                  30,
                  40,
                ],
              },
            },
            "kind": "metric",
            "process": Object {
              "eventLoopDelay": 100,
              "memory": Object {
                "heap": Object {
                  "usedInBytes": 200,
                },
              },
              "uptime": 3,
            },
          },
        ]
      `);
    });

    it('logs default metrics if they are missing or malformed', async () => {
      const opsLogger = logger.get('metrics', 'ops');
      mockOpsCollector.collect.mockResolvedValueOnce({ secondMetrics: 'metrics' });
      await metricsService.setup({ http: httpMock });
      await metricsService.start();
      expect(loggingSystemMock.collect(opsLogger).debug[1]).toMatchInlineSnapshot(`
        Array [
          "{}",
          Object {
            "category": Array [
              "process",
              "host",
            ],
            "ecs": Object {
              "version": "1.7.0",
            },
            "host": Object {
              "os": Object {
                "load": Array [],
              },
            },
            "kind": "metric",
            "process": Object {
              "eventLoopDelay": undefined,
              "memory": Object {
                "heap": Object {
                  "usedInBytes": undefined,
                },
              },
              "uptime": undefined,
            },
          },
        ]
      `);
    });
  });

  describe('#stop', () => {
    it('stops the metrics interval', async () => {
      await metricsService.setup({ http: httpMock });
      const { getOpsMetrics$ } = await metricsService.start();

      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(1);

      jest.advanceTimersByTime(testInterval);
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(2);

      await metricsService.stop();
      jest.advanceTimersByTime(10 * testInterval);
      expect(mockOpsCollector.collect).toHaveBeenCalledTimes(2);

      getOpsMetrics$().subscribe({ complete: () => {} });
    });

    it('completes the metrics observable', async () => {
      await metricsService.setup({ http: httpMock });
      const { getOpsMetrics$ } = await metricsService.start();

      let completed = false;

      getOpsMetrics$().subscribe({
        complete: () => {
          completed = true;
        },
      });

      await metricsService.stop();

      expect(completed).toEqual(true);
    });
  });
});
